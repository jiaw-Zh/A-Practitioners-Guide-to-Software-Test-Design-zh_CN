## 简介

等价类划分法是一种能够将测试用例的数量减少到可管理的水平，同时保持合理测试覆盖率的技术。几乎所有的测试人员都曾下意识的使用过这种简单的技术，尽管他们可能不知道它是一种正式的测试设计方法。许多测试人员已经从逻辑上推断出它的用法，而其他人发现它仅仅是因为没有时间进行更彻底的测试。

考虑下面这种情况，我们正在为人力资源系统编写一个模块，该模块决定如何根据一个人的年龄处理就业申请。规则如下：

```
0 –16 ： 不予雇佣
16–18 ： 只能兼职雇用
18–55 ： 可以聘请为全职员工
55–99 ： 不予雇佣
```

&nbsp;&nbsp; **注解：** 如果您发现这些规则存在问题，请不要担心，这样写是有目的的，将在下一章中修复。

**观察**

有了这些规则，我们的组织就不会雇用 [Doogie Houser, M.D.](https://zh.wikipedia.org/wiki/%E5%B0%BC%E7%88%BE%C2%B7%E6%9F%8F%E5%BE%B7%E7%83%88%C2%B7%E5%A4%8F%E9%87%8C%E6%96%AF) (电视剧《天才小医生》主角) 或 Col. Harlan Sanders(肯德基的创始人)，一个太年轻，另一个太老。

我们是否需要使用以下年龄段来测试上面的规则：0, 1, 2, 3, 4, 5, 6, 7, 8, ..., 90, 91, 92, 93, 94, 95, 96, 97, 98, 99。如果我们有很多时间当然是可以的（我不介意这种令人麻木的重复，我们是按小时计酬的）。如果程序是下面这样实现的，我们需要测试所有年龄（如果你没有编程背景，也不要担心，这些例子很简单，只需阅读代码，你就会懂它的意思）。

```java
If (applicantAge == 0) hireStatus="NO";
    If (applicantAge == 1) hireStatus="NO";
    …
    If (applicantAge == 14) hireStatus="NO";
    If (applicantAge == 15) hireStatus="NO";
    If (applicantAge == 16) hireStatus="PART";
    If (applicantAge == 17) hireStatus="PART";
    If (applicantAge == 18) hireStatus="FULL";
    If (applicantAge == 19) hireStatus="FULL";
    …
    If (applicantAge == 53) hireStatus="FULL";
    If (applicantAge == 54) hireStatus="FULL";
    If (applicantAge == 55) hireStatus="NO";
    If (applicantAge == 56) hireStatus="NO";
    …
    If (applicantAge == 98) hireStatus="NO";
    If (applicantAge == 99) hireStatus="NO";
```

鉴于此实现，任何一组测试通过的用例都不能告诉我们下一次测试可以执行什么样的用例，它可能会通过，也可能会失败。

幸运的是，程序员不会这么写程序（至少不会经常这么写），一个好点的程序员也许是这样写的：

```java
If (applicantAge >= 0 && applicantAge <=16)
        hireStatus="NO";
If (applicantAge >= 16 && applicantAge <=18)
        hireStatus="PART";
If (applicantAge >= 18 && applicantAge <=55)
        hireStatus="FULL";
If (applicantAge >= 55 && applicantAge <=99)
        hireStatus="NO";
```

很明显，对于上面这个常见实现的第一个要求，我们不必测试 0-16 的所有数字，只需要测试其中的一个数字就可以了，那么选什么数呢？所有这个范围的数字任何一个都可以。其他范围也是一样。这里的范围就可以定义为**等价类**。一个等价类包含一组数据，这些数据对程序或模块来说都是一样的。在测试中，类别中的任一数据都是和其他数据等价的。具体来说，我们希望：

- 如果一个等价类中的一条用例发现了缺陷，那么这个等价类中的所有其他测试用例都能够发现同样的缺陷。
- 如果一个等价类中的一条用例未发现缺陷，那么这个等价类中的所有其他测试用例也无法发现缺陷。

&nbsp;&nbsp; **关键点：** 如果你认为某一组用例形成了一个等价类，那么：

- &emsp; 他们都测试同样的东西。
- &emsp; 其中一条用例发现一个 bug，其他的很可能也会。
- &emsp; 其中一条用例没有发现 bug，其他的可能也不会。

&emsp;&emsp;&emsp; Cem Kaner  `Testing Computer Software`

当然，这种方法假设存在一个定义了各种等价类的规范，它还假设程序员没有做一些奇怪的事情，比如

```java
If (applicantAge >= 0 && applicantAge <=16)
            hireStatus="NO";
If (applicantAge >= 16 && applicantAge <=18)
            hireStatus="PART";
If (applicantAge >= 18 && applicantAge <=41)
            hireStatus="FULL";
// strange statements follow
If (applicantAge == 42 && applicantName == "Lee")
            hireStatus="HIRE NOW AT HUGE SALARY";
If (applicantAge == 42 && applicantName <> "Lee")
            hireStatus="FULL";
// end of strange statements

If (applicantAge >= 43 && applicantAge <=55)
            hireStatus="FULL";
If (applicantAge >= 55 && applicantAge <=99)
            hireStatus="NO";
```

使用等价类方法，我们将测试用例的数量从 100 个（测试每个年龄）减少到 4 个（每个等价类测试一个年龄）——这是一个显著的节约。

现在，我们准备好开始测试了吗？也许还没有，我们需要为像 969、-42、FRED 和 &$#!@ 这样的无效输入值构建用例吗？正如任何优秀的顾问都会告诉你的那样，答案是：“这要看情况”。为了理解这个答案，我们需要了解一种来自面向对象编程的方法，称为**契约式设计**。

&nbsp;&nbsp; **注解：** 根据圣经，Methuselah 是在969岁死的，感谢 Gideons 创造了这么好记的数据而不需要上网查。

在法律上，契约是两方（或多方）之间具有法律约束力的协议，定义双方能做什么和不能做什么，各自承诺形成互利。

在契约式设计中，模块（在面向对象范式中称为“方法”，但“模块”是一个更通用的术语）是由前置条件和后置条件定义的。后置条件定义了模块需要做什么（计算一个值，打开一个文件，打印一个报表，更新数据库记录，改变系统状态等）。前置条件定义了模块所需的内容，以便满足其后置条件。比如：你有一个模块叫做 openFile，它需要做什么？打开一个文件。打开文件的合理前提是什么？第一，文件是存在的。第二，我们需要提供文件名称或其他可识别信息。第三，该文件必须是“可打开的”，也就是说，它不能已经被另一个进程以独占方式打开。第四，我们需要有权限，等等。前置条件和后置条件在模块和调用它的其他模块之间建立契约。

**契约式测试**基于契约式设计哲学，它的思路是只为满足前提条件的情况创建测试用例。比如，对于 openFile 模块我们不会测试文件不存在的情况，理由很简单，如果文件不存在，openFile 模块没有承诺需要可以工作。如果没有声明它将在特定条件下工作，则无需测试该条件。

&nbsp;&nbsp;  **更多信息：** 关于契约式设计的更多信息，可以看 Bertrand Meyer 的书： `Object-Oriented Software Construction`

此时测试人员通常会提出抗议。是的，他们同意该模块并没有声称在这种情况下可以工作，但是如果在生产过程中违反了前置条件怎么办？系统会怎么做？我们是能在屏幕上看到一个拼写错误的单词还是冒个烟？

另一种不一样的设计方法是**防御式设计**。在这种情况下，模块被设计为可以接受任何输入。如果遵循了前置条件，模块将达到其正常的后置条件。如果没有遵循前置条件，模块会返回一个错误码，抛个异常（取决于所使用的语言）等以通知调用者，这个通知实际上是模块的另一个后置条件。基于此方法我们可以定义**防御式测试**：一种在正常和异常前提条件下进行测试的方法。

&nbsp;&nbsp; **看点：** 我班的一个学生，我们叫他 Fred 吧，他说他并不真正关心正在使用哪种设计方法，他经常用的就是防御式测试。当我问为什么？他说，如果模块不工作，应该是谁的责任？负责人还是测试人员？

上面两种设计方法怎么样应用于等价类呢？我们需要测试像 -42、FRED 和 &$#!@ 这样的输入吗？如果我们用契约式设计和契约式测试答案是否，如果我们是防御性设计和防御式测试，答案是是。问一下程序设计人员他们用的什么方法，如果答案是契约或者防御式设计，那么你知道应该要怎么测试。如果是“啊？”，意味着设计人员没有考虑过模块如何对接，也没有考虑过前置条件和后置条件的契约。那么集成测试将会是发现缺陷的主要十七，这些缺陷将比预期的更复杂并花费更多时间。