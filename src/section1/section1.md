# 第一节：黑盒测试技术

## 章节列表

 [第三章](chapter3/overview.md) ： 等价类

 [第四章](chapter4/overview.md) ： 边界值

 [第五章](chapter5/overview.md) ： 判定表

 [第六章](chapter6/overview.md) ： 正交法

 [第七章](chapter7/overview.md) ： 状态迁移

 [第八章](chapter8/overview.md) ： 域分析

 [第九章](chapter9/overview.md) ： 用例测试

 ## 部分概述

 ### 定义

 黑盒测试是一种完全基于需求和规范的测试策略。与白盒测试不同，黑盒测试不需要了解被测软件(SUT)的内部路径、结构或实现。

 ![黑白](../section0/chapter1/img/黑白.jpg)

黑盒测试的一般流程是：
- 需求分析
- 验证被测系统是否能够正确处理基于规范的有效输入和无效输入
- 确定预期结果
- 使用选定的输入构建测试
- 运行测试
- 比较实际结果和预期结果
- 确定被测软件的正常功能

### 适用性

黑盒测试可以应用于系统开发的各个层级 —— 单元测试、集成测试、系统测试和验收测试。

![测试层级](img/levels.jpg)

即使软件规模从模块到子系统再到系统不断增大，输入和输出越来越复杂，但测试方法依然可以保持不变。同时，随着规模的扩大，使用白盒测试会有太多的路径需要执行，因此我们只能采用黑盒测试。

### 劣势

当使用黑盒测试时，测试人员永远无法确定测试覆盖率有多少。无论测试人员多么聪明或勤奋，某些路径也许就是覆盖不到。比如下面的例子，使用一条测试用例就能发现该程序“功能”的概率有多少？

```java
if (name=="Lee" && employeeNumber=="1234" &&
    employmentStatus=="RecentlyTerminatedForCause") {
    send Lee a check for $1,000,000;
}
```

&nbsp;&nbsp; **关键点：** 使用黑盒测试时，测试人员永远无法确定已经测试了多少。

为了使用黑盒测试发现所有缺陷，测试人员需要构建所有可能的有效和无效的输入组合。然而这种详尽的输入测试几乎是不可能的，我们只能选择输入组合的一个子集（通常是一个非常小的子集）。

在 *The Art of Software Testing* 一书中，Glenford Myers 提供了一个很好的例子，说明了详尽的测试是徒劳的：怎么样完全测试一个编译器？通过编写所有可能的有效和无效程序。对于那些必须记住以前发生过的事情（即，记住它们的状态）的系统来说问题更严重，在这些系统中，我们不仅必须测试每个可能的输入，还必须测试每个可能输入的可能顺序。

&nbsp;&nbsp; **关键点：** 尽管我们无法测试所有内容，但规范的的黑盒测试会指导测试人员选择在发现缺陷方面既高效又有效的测试子集。

### 优势

尽管我们无法测试所有内容，但规范的的黑盒测试会指导测试人员选择在发现缺陷方面既高效又有效的测试子集，这些子集能够比随机选取同样数量测试用例发现更多的缺陷。规范的黑盒测试有助于最大限度地提高我们的测试投资回报。。

### 参考
&nbsp;&nbsp; Myers, Glenford J. (1979). *The Art of Software Testing.* John Wiley & Sons.